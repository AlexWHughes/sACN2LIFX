<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sACN2LIFX Control</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f0f0f0;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        header {
            background: #2c3e50;
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .status-bar {
            background: #f5f5f5;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #ddd;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-indicator.running {
            background: #4caf50;
            box-shadow: 0 0 8px #4caf50;
        }
        
        .status-indicator.stopped {
            background: #f44336;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            margin: 0 5px;
        }
        
        .btn-primary {
            background: #3498db;
            color: white;
        }
        
        .btn-primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
        }
        
        .btn-success {
            background: #4caf50;
            color: white;
        }
        
        .btn-success:hover {
            background: #45a049;
        }
        
        .btn-danger {
            background: #f44336;
            color: white;
        }
        
        .btn-danger:hover {
            background: #da190b;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .content {
            padding: 30px;
        }
        
        .section {
            margin-bottom: 30px;
        }
        
        .section h2 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.5em;
        }
        
        .lights-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .light-card {
            background: #f9f9f9;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            transition: all 0.3s;
        }
        
        .light-card:hover {
            border-color: #3498db;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
        }
        
        .light-card.mapped {
            border-color: #4caf50;
            background: #f1f8f4;
        }
        
        .light-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .light-label {
            font-weight: 600;
            font-size: 1.1em;
            color: #333;
        }
        
        .light-ip {
            font-size: 0.9em;
            color: #666;
        }
        
        .mapping-form {
            display: grid;
            gap: 10px;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
        }
        
        .form-group label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }
        
        .form-group input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .form-group input:focus {
            outline: none;
            border-color: #3498db;
        }
        
        .btn-small {
            padding: 8px 16px;
            font-size: 12px;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px;
            color: #999;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #3498db;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            background: #4caf50;
            color: white;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            display: none;
            z-index: 1000;
        }
        
        .notification.error {
            background: #f44336;
        }
        
        .notification.show {
            display: block;
            animation: slideIn 0.3s;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>sACN2LIFX Control</h1>
            <p>Created by Alex Hughes</p>
        </header>
        
        <div class="status-bar">
            <div>
                <span class="status-indicator" id="statusIndicator"></span>
                <span id="statusText">Stopped</span>
                <span id="statusDetails" style="margin-left: 15px; color: #666;"></span>
                <span id="dmxStatus" style="margin-left: 20px; color: #666; font-size: 0.9em;"></span>
            </div>
            <div>
                <button class="btn btn-primary" onclick="discoverLights()">Discover Lights</button>
                <button class="btn btn-primary" onclick="reloadConfig()" style="background: #9b59b6;" title="Reload configuration from config.json">Reload Config</button>
                <button class="btn btn-success" id="startBtn" onclick="startDMX()">Start DMX</button>
                <button class="btn btn-danger" id="stopBtn" onclick="stopDMX()" disabled>Stop DMX</button>
            </div>
        </div>
        
        <div class="content">
            <div class="section">
                <h2>Network Settings</h2>
                <div style="background: #f9f9f9; padding: 15px; border-radius: 6px; margin-bottom: 20px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 15px;">
                        <div class="form-group">
                            <label>LIFX Interface</label>
                            <select id="lifxInterfaceSelect" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; width: 100%;">
                                <option value="">Loading interfaces...</option>
                            </select>
                            <small style="color: #666; font-size: 0.85em; display: block; margin-top: 4px;">
                                Network interface for LIFX light discovery
                            </small>
                        </div>
                        <div class="form-group">
                            <label>sACN Interface</label>
                            <select id="sacnInterfaceSelect" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; width: 100%;">
                                <option value="">Loading interfaces...</option>
                            </select>
                            <small style="color: #666; font-size: 0.85em; display: block; margin-top: 4px;">
                                Network interface for sACN (DMX) reception
                            </small>
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="saveInterfaces()" style="margin-top: 10px;">Save & Apply Settings</button>
                </div>
            </div>
            
            <div class="section">
                <h2>Test RGB (DMX-less)</h2>
                <div style="background: #f9f9f9; padding: 15px; border-radius: 6px; margin-bottom: 20px;">
                    <p style="margin-bottom: 15px; color: #666; font-size: 0.9em;">
                        Test RGB values directly on configured lights without DMX. Useful for debugging refresh issues.
                    </p>
                    <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; padding: 10px; margin-bottom: 15px; font-size: 0.9em;">
                        <strong>⚠️ Important:</strong> Stop all animations before starting DMX processing to avoid conflicts and reduce network traffic.
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px; align-items: end;">
                        <div class="form-group" style="margin-bottom: 0;">
                            <label>Animation Update Interval (ms)</label>
                            <input type="number" id="animationUpdateInterval" value="200" min="50" max="1000" step="50" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; width: 100%;">
                            <small style="color: #666; font-size: 0.85em; display: block; margin-top: 4px;">
                                Network request rate for animations (default: 200ms = 5Hz). Lower values = smoother but more network traffic.
                            </small>
                        </div>
                        <div>
                            <button class="btn btn-danger" onclick="stopAllAnimations()" style="padding: 8px 16px;">Stop All Animations</button>
                        </div>
                    </div>
                    <div id="testRgbContainer" style="display: grid; gap: 15px;">
                        <!-- Test RGB controls will be rendered here -->
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h2>Manually Add Light</h2>
                <div style="background: #f9f9f9; padding: 15px; border-radius: 6px; margin-bottom: 20px;">
                    <p style="margin-bottom: 15px; color: #666; font-size: 0.9em;">
                        Add a light by IP address if it's not discoverable on your network.
                    </p>
                    <div style="display: grid; grid-template-columns: 2fr 2fr 1fr; gap: 15px; align-items: end;">
                        <div class="form-group" style="margin-bottom: 0;">
                            <label>IP Address</label>
                            <input type="text" id="manualLightIP" placeholder="e.g. 192.168.1.100" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; width: 100%;">
                        </div>
                        <div class="form-group" style="margin-bottom: 0;">
                            <label>Label (Optional)</label>
                            <input type="text" id="manualLightLabel" placeholder="e.g. Living Room Light" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; width: 100%;">
                        </div>
                        <div>
                            <button class="btn btn-primary" onclick="addManualLight()" style="width: 100%;">Add Light</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h2>Discovered Lights</h2>
                <div id="discoveredLightsContainer">
                    <div class="loading">Click "Discover Lights" to find LIFX devices on your network</div>
                </div>
            </div>
            
            <div class="section">
                <h2>Configured Lights</h2>
                <div id="configuredLightsContainer">
                    <div class="empty-state">No lights configured yet. Discover lights and add mappings to get started.</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="notification" id="notification"></div>
    
    <script>
        let lights = [];
        let running = false;
        
        function showNotification(message, isError = false) {
            const notif = document.getElementById('notification');
            notif.textContent = message;
            notif.className = 'notification' + (isError ? ' error' : '') + ' show';
            setTimeout(() => {
                notif.classList.remove('show');
            }, 3000);
        }
        
        async function validateJsonResponse(response) {
            const contentType = response.headers.get('content-type');
            // Clone response so we can read text if JSON parsing fails
            const clonedResponse = response.clone();
            
            // Try to parse JSON first - some servers may not set content-type correctly
            try {
                const data = await response.json();
                // If content-type doesn't match but we got valid JSON, log a warning but continue
                if (contentType && !contentType.includes('application/json')) {
                    console.warn('Response has non-JSON content-type but contains valid JSON:', contentType);
                }
                return data;
            } catch (jsonError) {
                // If JSON parsing fails, read the text for error message
                const text = await clonedResponse.text();
                const sanitizedText = text.replace(/[<>]/g, '').substring(0, 100).trim();
                if (!contentType || !contentType.includes('application/json')) {
                    throw new Error(`Server returned non-JSON response (${response.status})${sanitizedText ? ': ' + sanitizedText : ''}`);
                }
                // Content-type was JSON but parsing failed - include the JSON error
                throw new Error(`Failed to parse JSON response (${response.status}): ${jsonError.message}${sanitizedText ? ' - ' + sanitizedText : ''}`);
            }
        }
        
        async function addManualLight() {
            const ipInput = document.getElementById('manualLightIP');
            const labelInput = document.getElementById('manualLightLabel');
            const ip = ipInput.value.trim();
            const label = labelInput.value.trim();
            
            if (!ip) {
                showNotification('Please enter an IP address', true);
                return;
            }
            
            // Basic IP validation
            const ipRegex = /^(\d{1,3}\.){3}\d{1,3}$/;
            if (!ipRegex.test(ip)) {
                showNotification('Invalid IP address format', true);
                return;
            }
            
            try {
                const response = await fetch('/api/lights/manual', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ip, label })
                });
                
                const data = await validateJsonResponse(response);
                
                if (data.success) {
                    showNotification(`Light added${data.light.discovered ? ' and discovered' : ' (not discovered - will be configured when found)'}`);
                    ipInput.value = '';
                    labelInput.value = '';
                    loadLights();
                    updateStatus();
                } else {
                    showNotification('Failed to add light: ' + data.error, true);
                }
            } catch (error) {
                showNotification('Error: ' + error.message, true);
            }
        }
        
        async function discoverLights() {
            const discoverBtn = document.querySelector('button[onclick="discoverLights()"]');
            const discoveredContainer = document.getElementById('discoveredLightsContainer');
            
            // Show loading state
            discoverBtn.disabled = true;
            discoveredContainer.innerHTML = '<div class="loading">Please wait while discovering lights...<br><small>This may take up to 7 seconds</small></div>';
            
            try {
                const response = await fetch('/api/lights/discover', { method: 'POST' });
                
                const data = await validateJsonResponse(response);
                
                if (data.success) {
                    lights = data.lights;
                    showNotification(`Discovered ${lights.length} light(s)`);
                    // Reload lights to get properly separated lists from backend
                    loadLights();
                } else {
                    showNotification('Discovery failed: ' + data.error, true);
                    document.getElementById('discoveredLightsContainer').innerHTML = '<div class="empty-state">Discovery failed. Please try again.</div>';
                }
            } catch (error) {
                showNotification('Error: ' + error.message, true);
                document.getElementById('discoveredLightsContainer').innerHTML = '<div class="empty-state">Error during discovery. Please try again.</div>';
            } finally {
                discoverBtn.disabled = false;
            }
        }
        
        function saveFormValues() {
            // Save form values for both unconfigured and configured (edit) lights before re-rendering
            const formValues = {};
            const openEditForms = [];
            
            // Save values from discovered (unconfigured) lights
            const discoveredContainer = document.getElementById('discoveredLightsContainer');
            if (discoveredContainer) {
                const inputs = discoveredContainer.querySelectorAll('input[type="number"], select');
                inputs.forEach(input => {
                    if (input.value && input.value.trim() !== '') {
                        formValues[input.id] = input.value;
                    }
                });
            }
            
            // Save values from configured lights edit forms (only if form is visible)
            const configuredContainer = document.getElementById('configuredLightsContainer');
            if (configuredContainer) {
                const editForms = configuredContainer.querySelectorAll('[id^="edit-form-"]');
                editForms.forEach(form => {
                    // Only save if the form is visible (being edited)
                    if (form.style.display !== 'none') {
                        const lightId = form.id.replace('edit-form-', '');
                        openEditForms.push(lightId);
                        const inputs = form.querySelectorAll('input[type="number"], select');
                        inputs.forEach(input => {
                            if (input.value && input.value.trim() !== '') {
                                formValues[input.id] = input.value;
                            }
                        });
                    }
                });
            }
            
            return { formValues, openEditForms };
        }
        
        function restoreFormValues(savedData) {
            const { formValues, openEditForms } = savedData;
            
            // Restore form values after re-rendering
            Object.keys(formValues).forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.value = formValues[id];
                }
            });
            
            // Re-open edit forms that were open
            openEditForms.forEach(lightId => {
                const editForm = document.getElementById(`edit-form-${lightId}`);
                const viewMode = document.getElementById(`view-mode-${lightId}`);
                if (editForm && viewMode) {
                    editForm.style.display = 'block';
                    viewMode.style.display = 'none';
                }
            });
        }
        
        async function loadLights() {
            try {
                // Save form values before re-rendering
                const savedData = saveFormValues();
                
                const response = await fetch('/api/lights');
                const data = await response.json();
                
                if (data.success) {
                    lights = data.lights; // Keep for backward compatibility
                    renderLights(data); // Pass the full response data
                    // Restore form values and open edit forms after re-rendering
                    restoreFormValues(savedData);
                } else {
                    console.error('Failed to load lights:', data.error);
                }
            } catch (error) {
                console.error('Error loading lights:', error);
            }
        }
        
        function getChannelModeDescription(mode) {
            const descriptions = {
                'RGB (8bit)': '3 channels: Red, Green, Blue (8-bit, 0-255)',
                'RGB (16bit)': '6 channels: Red, Green, Blue (16-bit, MSB+LSB per color, 0-65535)',
                'RGBW (8bit)': '4 channels: Red, Green, Blue, White (8-bit)',
                'RGBW (16bit)': '8 channels: Red, Green, Blue, White (16-bit, MSB+LSB per color, 0-65535)',
                'HSBK (8bit)': '4 channels: Hue, Saturation, Brightness, Kelvin (8-bit, 2500-9000K)',
                'HSBK (16bit)': '8 channels: Hue, Saturation, Brightness, Kelvin (16-bit, MSB+LSB per parameter)'
            };
            return descriptions[mode] || descriptions['RGB (8bit)'];
        }
        
        function updateChannelModeDescription(lightId, isEdit = false) {
            const prefix = isEdit ? 'edit-' : '';
            const select = document.getElementById(`${prefix}channel-mode-${lightId}`);
            const desc = document.getElementById(`${prefix}channel-mode-desc-${lightId}`);
            if (select && desc) {
                desc.textContent = getChannelModeDescription(select.value);
            }
        }
        
        function editMapping(lightId) {
            document.getElementById(`view-mode-${lightId}`).style.display = 'none';
            document.getElementById(`edit-form-${lightId}`).style.display = 'block';
        }
        
        function cancelEdit(lightId) {
            document.getElementById(`view-mode-${lightId}`).style.display = 'block';
            document.getElementById(`edit-form-${lightId}`).style.display = 'none';
            // Reload to reset form values
            loadLights();
        }
        
        async function updateMapping(lightId) {
            const universe = document.getElementById(`edit-universe-${lightId}`).value.trim();
            const startChannel = document.getElementById(`edit-channel-${lightId}`).value.trim();
            const brightness = document.getElementById(`edit-brightness-${lightId}`).value.trim();
            const channelMode = document.getElementById(`edit-channel-mode-${lightId}`).value;
            
            if (!universe || !startChannel) {
                showNotification('Please fill in Universe and Start Channel', true);
                return;
            }
            
            const universeNum = parseInt(universe);
            const channelNum = parseInt(startChannel);
            const brightnessNum = brightness ? parseFloat(brightness) / 100 : null;
            
            if (isNaN(universeNum) || universeNum < 1) {
                showNotification('Universe must be a valid number greater than 0', true);
                return;
            }
            if (isNaN(channelNum) || channelNum < 1) {
                showNotification('Start Channel must be a valid number greater than 0', true);
                return;
            }
            
            try {
                const requestBody = {
                    light_id: lightId,
                    universe: universeNum,
                    start_channel: channelNum,
                    channel_mode: channelMode || 'RGB'
                };
                
                if (brightnessNum !== null && !isNaN(brightnessNum)) {
                    requestBody.brightness = brightnessNum;
                }
                
                const response = await fetch('/api/mappings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                const data = await validateJsonResponse(response);
                
                if (data.success) {
                    showNotification('Mapping updated successfully');
                    loadLights();
                    updateStatus();
                } else {
                    showNotification('Failed to update mapping: ' + (data.error || 'Unknown error'), true);
                }
            } catch (error) {
                console.error('Error updating mapping:', error);
                showNotification('Error: ' + error.message, true);
            }
        }
        
        function renderLights(data) {
            const discoveredContainer = document.getElementById('discoveredLightsContainer');
            const configuredContainer = document.getElementById('configuredLightsContainer');
            
            // Backend now handles all deduplication and separation - just use what it provides
            const configuredLights = data.configured_lights || [];
            const unconfiguredLights = data.unconfigured_lights || [];
            const manualLights = data.manual_lights || [];
            const allConfiguredLights = data.all_configured_lights || [];
            
            // Render configured lights
            if (allConfiguredLights.length === 0) {
                configuredContainer.innerHTML = '<div class="empty-state">No lights configured yet. Discover lights and add mappings to get started.</div>';
            } else {
                configuredContainer.innerHTML = allConfiguredLights.map(light => {
                    const mapping = light.mapping || {};
                    const isDiscovered = light.discovered !== false;
                    const hasConfig = mapping.universe !== undefined && mapping.start_channel !== undefined && 
                                     mapping.universe !== null && mapping.start_channel !== null;
                    return `
                        <div class="light-card mapped">
                            <div class="light-header">
                                <div>
                                    <div class="light-label">${light.label}</div>
                                    <div class="light-ip">${light.ip}</div>
                                    <div class="light-model" style="font-size: 0.85em; color: #666; margin-top: 4px;">${light.model || 'Unknown Model'}</div>
                                    ${!isDiscovered ? '<div style="font-size: 0.85em; color: #f44336; margin-top: 4px; font-weight: 600;">⚠️ Not currently discovered - click "Discover Lights" to reconnect</div>' : ''}
                                    ${!hasConfig ? '<div style="font-size: 0.85em; color: #ff9800; margin-top: 4px; font-weight: 600;">⚠️ Configuration needed - set Universe and Start Channel below</div>' : ''}
                                    ${hasConfig ? `<div style="font-size: 0.85em; color: #4caf50; margin-top: 4px; font-weight: 600;">
                                        Universe ${mapping.universe}, Channel ${mapping.start_channel} (${mapping.channel_mode || 'RGB'})
                                    </div>` : ''}
                                </div>
                            </div>
                            <div class="mapping-form" id="edit-form-${light.id}" style="display: none;">
                                <div class="form-group">
                                    <label>Universe</label>
                                    <input type="number" id="edit-universe-${light.id}" value="${mapping.universe || ''}" placeholder="e.g. 1" min="1">
                                </div>
                                <div class="form-group">
                                    <label>Start Channel</label>
                                    <input type="number" id="edit-channel-${light.id}" value="${mapping.start_channel || ''}" placeholder="e.g. 1" min="1">
                                </div>
                                <div class="form-group">
                                    <label>Brightness (%)</label>
                                    <input type="number" id="edit-brightness-${light.id}" value="${mapping.brightness !== undefined ? (mapping.brightness * 100) : 100}" step="1" min="0" max="100">
                                </div>
                                <div class="form-group">
                                    <label>Channel Mode</label>
                                    <select id="edit-channel-mode-${light.id}" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; width: 100%;" onchange="updateChannelModeDescription('${light.id}', true)">
                                        ${(light.supported_modes || ['RGB (8bit)']).map(mode => 
                                            `<option value="${mode}" ${mapping.channel_mode === mode ? 'selected' : (mode === 'RGB (8bit)' && !mapping.channel_mode ? 'selected' : '')}>${mode}</option>`
                                        ).join('')}
                                    </select>
                                    <small id="edit-channel-mode-desc-${light.id}" style="color: #666; font-size: 0.85em; display: block; margin-top: 4px;">
                                        ${getChannelModeDescription(mapping.channel_mode || 'RGB (8bit)')}
                                    </small>
                                </div>
                                <button class="btn btn-primary btn-small" onclick="updateMapping('${light.id}')">Save Changes</button>
                                <button class="btn btn-danger btn-small" onclick="cancelEdit('${light.id}')">Cancel</button>
                            </div>
                            <div id="view-mode-${light.id}">
                                <button class="btn btn-primary btn-small" onclick="editMapping('${light.id}')">Edit</button>
                                <button class="btn btn-danger btn-small" onclick="deleteMapping('${light.id}')">Delete</button>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            // Render test RGB controls for configured lights
            renderTestRgbControls(allConfiguredLights);
            
            // Render discovered (unconfigured) lights
            if (unconfiguredLights.length === 0) {
                discoveredContainer.innerHTML = '<div class="empty-state">All discovered lights are configured.</div>';
            } else {
                discoveredContainer.innerHTML = unconfiguredLights.map(light => {
                    return `
                        <div class="light-card">
                            <div class="light-header">
                                <div>
                                    <div class="light-label">${light.label}</div>
                                    <div class="light-ip">${light.ip}</div>
                                    <div class="light-model" style="font-size: 0.85em; color: #666; margin-top: 4px;">${light.model || 'Unknown Model'}</div>
                                </div>
                            </div>
                            <div class="mapping-form">
                                <div class="form-group">
                                    <label>Universe</label>
                                    <input type="number" id="universe-${light.id}" placeholder="e.g. 1" min="1">
                                </div>
                                <div class="form-group">
                                    <label>Start Channel</label>
                                    <input type="number" id="channel-${light.id}" placeholder="e.g. 1" min="1">
                                </div>
                                <div class="form-group">
                                    <label>Brightness (%)</label>
                                    <input type="number" id="brightness-${light.id}" value="100" step="1" min="0" max="100">
                                </div>
                                <div class="form-group">
                                    <label>Channel Mode</label>
                                    <select id="channel-mode-${light.id}" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; width: 100%;" onchange="updateChannelModeDescription('${light.id}')">
                                        ${(light.supported_modes || ['RGB (8bit)']).map(mode => 
                                            `<option value="${mode}" ${mode === 'RGB (8bit)' ? 'selected' : ''}>${mode}</option>`
                                        ).join('')}
                                    </select>
                                    <small id="channel-mode-desc-${light.id}" style="color: #666; font-size: 0.85em; display: block; margin-top: 4px;">
                                        ${getChannelModeDescription('RGB (8bit)')}
                                    </small>
                                </div>
                                <button class="btn btn-primary btn-small" onclick="saveMapping('${light.id}')">Add Configuration</button>
                            </div>
                        </div>
                    `;
                }).join('');
            }
        }
        
        async function saveMapping(lightId) {
            const universe = document.getElementById(`universe-${lightId}`).value;
            const startChannel = document.getElementById(`channel-${lightId}`).value;
            const brightness = document.getElementById(`brightness-${lightId}`).value;
            const channelMode = document.getElementById(`channel-mode-${lightId}`).value;
            
            if (!universe || !startChannel) {
                showNotification('Please fill in Universe and Start Channel', true);
                return;
            }
            
            try {
                const response = await fetch('/api/mappings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        light_id: lightId,
                        universe: parseInt(universe),
                        start_channel: parseInt(startChannel),
                        brightness: parseFloat(brightness) / 100,
                        channel_mode: channelMode
                    })
                });
                
                const data = await validateJsonResponse(response);
                
                if (data.success) {
                    showNotification('Mapping saved successfully');
                    loadLights();
                    updateStatus();
                } else {
                    showNotification('Failed to save mapping: ' + data.error, true);
                }
            } catch (error) {
                showNotification('Error: ' + error.message, true);
            }
        }
        
        async function deleteMapping(lightId) {
            try {
                const response = await fetch(`/api/mappings/${lightId}`, { method: 'DELETE' });
                
                const data = await validateJsonResponse(response);
                
                if (data.success) {
                    showNotification('Mapping removed');
                    loadLights();
                    updateStatus();
                } else {
                    showNotification('Failed to remove mapping: ' + (data.error || 'Unknown error'), true);
                }
            } catch (error) {
                showNotification('Error: ' + error.message, true);
            }
        }
        
        async function startDMX() {
            try {
                // Stop all animations before starting DMX to avoid conflicts
                stopAllAnimations();
                
                const response = await fetch('/api/control/start', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    running = true;
                    showNotification('DMX processing started (all animations stopped)');
                    updateStatus();
                } else {
                    showNotification('Failed to start: ' + data.error, true);
                }
            } catch (error) {
                showNotification('Error: ' + error.message, true);
            }
        }
        
        async function stopDMX() {
            try {
                const response = await fetch('/api/control/stop', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    running = false;
                    showNotification('DMX processing stopped');
                    updateStatus();
                } else {
                    showNotification('Failed to stop', true);
                }
            } catch (error) {
                showNotification('Error: ' + error.message, true);
            }
        }
        function renderTestRgbControls(configuredLights) {
            const container = document.getElementById('testRgbContainer');
            if (!container) return;
            
            if (!configuredLights || configuredLights.length === 0) {
                container.innerHTML = '<div class="empty-state">No configured lights to test. Configure a light first.</div>';
                return;
            }
            
            container.innerHTML = configuredLights.map(light => {
                return `
                    <div style="background: #fff; border: 1px solid #e0e0e0; border-radius: 6px; padding: 15px;">
                        <div style="font-weight: 600; margin-bottom: 12px; color: #333;">${light.label}</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr 1fr; gap: 10px; align-items: end;">
                            <div class="form-group" style="margin-bottom: 0;">
                                <label style="font-size: 0.85em;">Red (0-255)</label>
                                <input type="number" id="test-r-${light.id}" value="0" min="0" max="255" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; width: 100%;">
                            </div>
                            <div class="form-group" style="margin-bottom: 0;">
                                <label style="font-size: 0.85em;">Green (0-255)</label>
                                <input type="number" id="test-g-${light.id}" value="0" min="0" max="255" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; width: 100%;">
                            </div>
                            <div class="form-group" style="margin-bottom: 0;">
                                <label style="font-size: 0.85em;">Blue (0-255)</label>
                                <input type="number" id="test-b-${light.id}" value="0" min="0" max="255" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; width: 100%;">
                            </div>
                            <div class="form-group" style="margin-bottom: 0;">
                                <label style="font-size: 0.85em;">Brightness (0-100%)</label>
                                <input type="number" id="test-brightness-${light.id}" value="100" min="0" max="100" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; width: 100%;">
                            </div>
                            <button class="btn btn-primary btn-small" onclick="testRgb('${light.id}')" style="padding: 8px 16px;">Test</button>
                        </div>
                        <div style="margin-top: 10px; display: flex; gap: 8px; flex-wrap: wrap;">
                            <button class="btn btn-small" onclick="setTestColor('${light.id}', 255, 0, 0)" style="background: #f44336; color: white; padding: 6px 12px; font-size: 0.85em;">Red</button>
                            <button class="btn btn-small" onclick="setTestColor('${light.id}', 0, 255, 0)" style="background: #4caf50; color: white; padding: 6px 12px; font-size: 0.85em;">Green</button>
                            <button class="btn btn-small" onclick="setTestColor('${light.id}', 0, 0, 255)" style="background: #2196f3; color: white; padding: 6px 12px; font-size: 0.85em;">Blue</button>
                            <button class="btn btn-small" onclick="setTestColor('${light.id}', 255, 255, 255)" style="background: #fff; color: #333; border: 1px solid #ddd; padding: 6px 12px; font-size: 0.85em;">White</button>
                            <button class="btn btn-small" onclick="setTestColor('${light.id}', 0, 0, 0)" style="background: #333; color: white; padding: 6px 12px; font-size: 0.85em;">Black</button>
                            <button class="btn btn-small" id="chase-btn-${light.id}" onclick="toggleRgbChase('${light.id}')" style="background: #ff9800; color: white; padding: 6px 12px; font-size: 0.85em;">RGB Chase</button>
                            <button class="btn btn-small" id="sinewave-btn-${light.id}" onclick="toggleSinewave('${light.id}')" style="background: #9c27b0; color: white; padding: 6px 12px; font-size: 0.85em;">Sinewave</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function setTestColor(lightId, r, g, b) {
            document.getElementById(`test-r-${lightId}`).value = r;
            document.getElementById(`test-g-${lightId}`).value = g;
            document.getElementById(`test-b-${lightId}`).value = b;
            testRgb(lightId);
        }
        
        // Store animation intervals
        const animationIntervals = {};
        const animationStates = {};
        
        // Animation update interval (default: 200ms = 5Hz to reduce network traffic)
        let animationUpdateInterval = 200;
        
        // Throttle map for testRgb calls - tracks last network request time per light
        const testRgbThrottle = {};
        
        // Get animation update interval from UI or use default
        function getAnimationUpdateInterval() {
            const input = document.getElementById('animationUpdateInterval');
            if (input) {
                const value = parseInt(input.value);
                if (value >= 50 && value <= 1000) {
                    animationUpdateInterval = value;
                }
            }
            return animationUpdateInterval;
        }
        
        // Throttled version of testRgb - only sends network request if enough time has passed
        async function testRgbThrottled(lightId, force = false) {
            const now = Date.now();
            const lastCall = testRgbThrottle[lightId] || 0;
            const interval = getAnimationUpdateInterval();
            
            // If forced or enough time has passed, make the network request
            if (force || (now - lastCall) >= interval) {
                testRgbThrottle[lightId] = now;
                return await testRgb(lightId);
            }
            // Otherwise, just update the UI values without network request
            return Promise.resolve();
        }
        
        async function testRgb(lightId) {
            const r = parseInt(document.getElementById(`test-r-${lightId}`).value) || 0;
            const g = parseInt(document.getElementById(`test-g-${lightId}`).value) || 0;
            const b = parseInt(document.getElementById(`test-b-${lightId}`).value) || 0;
            const brightness = (parseInt(document.getElementById(`test-brightness-${lightId}`).value) || 100) / 100.0;
            
            try {
                const response = await fetch('/api/lights/test-rgb', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        light_id: lightId,
                        r: r,
                        g: g,
                        b: b,
                        brightness: brightness,
                        fade_ms: 20
                    })
                });
                
                const data = await validateJsonResponse(response);
                
                if (data.success) {
                    showNotification(`Sent RGB(${r},${g},${b}) to ${data.light_label}`);
                } else {
                    showNotification('Failed to send RGB: ' + data.error, true);
                }
            } catch (error) {
                showNotification('Error: ' + error.message, true);
            }
        }
        
        function stopAnimation(lightId, animationType) {
            const key = `${lightId}-${animationType}`;
            if (animationIntervals[key]) {
                clearInterval(animationIntervals[key]);
                delete animationIntervals[key];
                delete animationStates[key];
            }
            // Clear throttle for this light
            delete testRgbThrottle[lightId];
        }
        
        function stopAllAnimations() {
            // Stop all running animations
            for (const key in animationIntervals) {
                clearInterval(animationIntervals[key]);
                delete animationIntervals[key];
            }
            for (const key in animationStates) {
                delete animationStates[key];
            }
            for (const key in testRgbThrottle) {
                delete testRgbThrottle[key];
            }
            
            // Reset all animation button states
            document.querySelectorAll('[id$="-chase"], [id$="-sinewave"]').forEach(btn => {
                if (btn.id.includes('-chase')) {
                    btn.textContent = 'RGB Chase';
                    btn.style.background = '#ff9800';
                } else if (btn.id.includes('-sinewave')) {
                    btn.textContent = 'Sinewave';
                    btn.style.background = '#9c27b0';
                }
            });
            
            showNotification('All animations stopped');
        }
        
        function toggleRgbChase(lightId) {
            const key = `${lightId}-chase`;
            const btn = document.getElementById(`chase-btn-${lightId}`);
            
            // Stop sinewave if running
            stopAnimation(lightId, 'sinewave');
            const sinewaveBtn = document.getElementById(`sinewave-btn-${lightId}`);
            if (sinewaveBtn) {
                sinewaveBtn.textContent = 'Sinewave';
                sinewaveBtn.style.background = '#9c27b0';
            }
            
            if (animationIntervals[key]) {
                // Stop chase
                stopAnimation(lightId, 'chase');
                btn.textContent = 'RGB Chase';
                btn.style.background = '#ff9800';
            } else {
                // Start chase
                const colors = [
                    { r: 255, g: 0, b: 0 },   // Red
                    { r: 0, g: 255, b: 0 },   // Green
                    { r: 0, g: 0, b: 255 }    // Blue
                ];
                let colorIndex = 0;
                
                // Set initial color
                const initialColor = colors[colorIndex];
                document.getElementById(`test-r-${lightId}`).value = initialColor.r;
                document.getElementById(`test-g-${lightId}`).value = initialColor.g;
                document.getElementById(`test-b-${lightId}`).value = initialColor.b;
                testRgb(lightId); // Send initial color immediately
                
                const updateInterval = getAnimationUpdateInterval();
                animationIntervals[key] = setInterval(() => {
                    colorIndex = (colorIndex + 1) % colors.length;
                    const color = colors[colorIndex];
                    document.getElementById(`test-r-${lightId}`).value = color.r;
                    document.getElementById(`test-g-${lightId}`).value = color.g;
                    document.getElementById(`test-b-${lightId}`).value = color.b;
                    testRgbThrottled(lightId); // Use throttled version
                }, updateInterval);
                
                btn.textContent = 'Stop Chase';
                btn.style.background = '#f44336';
            }
        }
        
        function toggleSinewave(lightId) {
            const key = `${lightId}-sinewave`;
            const btn = document.getElementById(`sinewave-btn-${lightId}`);
            
            // Stop chase if running
            stopAnimation(lightId, 'chase');
            const chaseBtn = document.getElementById(`chase-btn-${lightId}`);
            if (chaseBtn) {
                chaseBtn.textContent = 'RGB Chase';
                chaseBtn.style.background = '#ff9800';
            }
            
            if (animationIntervals[key]) {
                // Stop sinewave
                stopAnimation(lightId, 'sinewave');
                btn.textContent = 'Sinewave';
                btn.style.background = '#9c27b0';
            } else {
                // Start sinewave
                if (!animationStates[key]) {
                    animationStates[key] = { phase: 0 };
                }
                
                const state = animationStates[key];
                const visualUpdateInterval = 50; // Update UI every 50ms for smooth visual feedback
                const networkUpdateInterval = getAnimationUpdateInterval(); // Network requests at configured rate
                const speed = 0.02; // Speed of sinewave (adjust for faster/slower)
                
                // Send initial color immediately
                const initialR = Math.floor((Math.sin(state.phase) + 1) / 2 * 255);
                const initialG = Math.floor((Math.sin(state.phase + (2 * Math.PI / 3)) + 1) / 2 * 255);
                const initialB = Math.floor((Math.sin(state.phase + (4 * Math.PI / 3)) + 1) / 2 * 255);
                document.getElementById(`test-r-${lightId}`).value = initialR;
                document.getElementById(`test-g-${lightId}`).value = initialG;
                document.getElementById(`test-b-${lightId}`).value = initialB;
                testRgb(lightId); // Send initial color immediately
                
                // Update UI frequently for smooth visual feedback, but throttle network requests
                animationIntervals[key] = setInterval(() => {
                    state.phase += speed;
                    if (state.phase >= Math.PI * 2) {
                        state.phase -= Math.PI * 2;
                    }
                    
                    // Calculate RGB using sine waves with phase offsets
                    // Red: sine wave starting at 0
                    // Green: sine wave starting at 2π/3 (120 degrees)
                    // Blue: sine wave starting at 4π/3 (240 degrees)
                    const r = Math.floor((Math.sin(state.phase) + 1) / 2 * 255);
                    const g = Math.floor((Math.sin(state.phase + (2 * Math.PI / 3)) + 1) / 2 * 255);
                    const b = Math.floor((Math.sin(state.phase + (4 * Math.PI / 3)) + 1) / 2 * 255);
                    
                    // Always update UI for smooth visual feedback
                    document.getElementById(`test-r-${lightId}`).value = r;
                    document.getElementById(`test-g-${lightId}`).value = g;
                    document.getElementById(`test-b-${lightId}`).value = b;
                    
                    // Throttle network requests to reduce traffic
                    testRgbThrottled(lightId);
                }, visualUpdateInterval);
                
                btn.textContent = 'Stop Sinewave';
                btn.style.background = '#f44336';
            }
        }
        
        async function reloadConfig() {
            try {
                const response = await fetch('/api/config/reload', { method: 'POST' });
                const data = await validateJsonResponse(response);
                
                if (data.success) {
                    showNotification(`Configuration reloaded (${data.mappings_count} mappings)`);
                    loadLights();
                    updateStatus();
                } else {
                    showNotification('Failed to reload config: ' + (data.error || 'Unknown error'), true);
                }
            } catch (error) {
                showNotification('Error reloading config: ' + error.message, true);
            }
        }
        
        async function updateStatus() {
            try {
                const response = await fetch('/api/control/status');
                const data = await response.json();
                
                if (data.success) {
                    running = data.running;
                    const indicator = document.getElementById('statusIndicator');
                    const statusText = document.getElementById('statusText');
                    const statusDetails = document.getElementById('statusDetails');
                    const dmxStatus = document.getElementById('dmxStatus');
                    const startBtn = document.getElementById('startBtn');
                    const stopBtn = document.getElementById('stopBtn');
                    
                    if (running) {
                        indicator.className = 'status-indicator running';
                        statusText.textContent = 'Running';
                        statusText.style.color = '#000';
                        statusDetails.textContent = `${data.lights_count} lights, ${data.mappings_count} mapped`;
                        startBtn.disabled = true;
                        stopBtn.disabled = false;
                        
                        // Update DMX reception status
                        if (data.dmx_stats && Object.keys(data.dmx_stats).length > 0) {
                            const stats = data.dmx_stats;
                            if (stats.receiving) {
                                const universes = stats.active_universes.length > 0 
                                    ? stats.active_universes.join(', ') 
                                    : 'none';
                                const packets = stats.packets_received || 0;
                                dmxStatus.innerHTML = `<span style="color: #4caf50;">●</span> Receiving sACN | Universes: ${universes} | Packets: ${packets.toLocaleString()}`;
                            } else {
                                dmxStatus.innerHTML = `<span style="color: #f44336;">●</span> Waiting`;
                            }
                        } else {
                            dmxStatus.innerHTML = '';
                        }
                    } else {
                        indicator.className = 'status-indicator stopped';
                        statusText.textContent = 'Stopped';
                        statusText.style.color = '#000';
                        statusDetails.textContent = `${data.lights_count} lights, ${data.mappings_count} mapped`;
                        dmxStatus.innerHTML = '';
                        startBtn.disabled = false;
                        stopBtn.disabled = true;
                    }
                }
            } catch (error) {
                console.error('Error updating status:', error);
            }
        }
        
        async function loadInterfaces() {
            try {
                const response = await fetch('/api/interfaces');
                const data = await response.json();
                
                if (data.success) {
                    const lifxSelect = document.getElementById('lifxInterfaceSelect');
                    const sacnSelect = document.getElementById('sacnInterfaceSelect');
                    
                    const optionHtml = data.interfaces.map(iface => 
                        `<option value="${iface.ip}">${iface.display}</option>`
                    ).join('');
                    
                    lifxSelect.innerHTML = optionHtml;
                    sacnSelect.innerHTML = optionHtml;
                    
                    // Set selected values
                    if (data.lifx_interface) {
                        lifxSelect.value = data.lifx_interface;
                    }
                    if (data.sacn_interface) {
                        sacnSelect.value = data.sacn_interface;
                    }
                }
            } catch (error) {
                console.error('Error loading interfaces:', error);
            }
        }
        
        async function saveInterfaces() {
            const lifxSelect = document.getElementById('lifxInterfaceSelect');
            const sacnSelect = document.getElementById('sacnInterfaceSelect');
            
            const lifxIp = lifxSelect.value;
            const sacnIp = sacnSelect.value;
            
            if (!lifxIp || !sacnIp) {
                showNotification('Please select both interfaces', true);
                return;
            }
            
            try {
                // First save the settings
                const saveResponse = await fetch('/api/settings/interfaces', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        lifx_interface: lifxIp,
                        sacn_interface: sacnIp
                    })
                });
                
                const saveData = await saveResponse.json();
                
                if (!saveData.success) {
                    showNotification('Failed to save settings: ' + saveData.error, true);
                    return;
                }
                
                // Then apply the settings (recreate clients)
                const applyResponse = await fetch('/api/settings/interfaces/apply', {
                    method: 'POST'
                });
                
                const applyData = await applyResponse.json();
                
                if (applyData.success) {
                    showNotification('Network settings saved and applied successfully');
                } else {
                    showNotification('Settings saved but failed to apply: ' + applyData.error, true);
                }
            } catch (error) {
                showNotification('Error: ' + error.message, true);
            }
        }
        
        // Initial load
        loadInterfaces();
        loadLights();
        updateStatus();
        
        // Update status every 2 seconds
        setInterval(updateStatus, 2000);
    </script>
    <footer style="background: #2c3e50; color: white; padding: 20px; text-align: center; margin-top: 30px;">
        <div style="font-size: 0.9em;">
            <span>sACN2LIFX v{{ version }}</span>
            <span style="margin: 0 10px;">•</span>
            <a href="https://github.com/AlexWHughes/sACN2LIFX" target="_blank" rel="noopener noreferrer" style="color: #3498db; text-decoration: none;">
                GitHub
            </a>
        </div>
    </footer>
</body>
</html>

